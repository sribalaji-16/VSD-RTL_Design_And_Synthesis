# Introduction to Verilog RTL Design and Simulation Flow
This document outlines the standard workflow for digital logic design using open-source tools. It covers the role of the simulator (`Icarus Verilog`) and the waveform viewer (`GTKWave`) in the verification of Register Transfer Level (`RTL`) designs.

## Toolchain Overview
#### Icarus Verilog (The Engine)
- `Icarus Verilog` (iverilog) serves as the `compiler and simulator` for the Verilog Hardware Description Language (HDL).

- `Role` : It acts as the simulation engine. It parses the Verilog source code, checks for syntax errors, and compiles the logic into a binary executable that mimics the behavior of the digital circuit.

#### GTKWave (The Viewer)
- `GTKWave` is a `waveform visualization tool`.

- `Role`: It does not perform calculations or simulations itself. Instead, it visualizes the `output data` (Value Change Dump files) generated by the simulator. It renders logic states (High/Low) over a timeline, allowing for visual inspection of signal propagation.

## Purpose of Simulation
The simulation phase is critical in the VLSI flow for `Functional Verification`. We utilize this toolchain to:

- `Error Detection`: Identify syntax errors and logic flaws before synthesis.

- `Signal Analysis`: Calculate and record signal transitions over time to verify timing diagrams.

- `Iterative Debugging`: Inspect specific instances where signals transition to Logic High (1) or Low (0). This allows designers to pinpoint timing mismatches or race conditions and rewrite the HDL code until the design meets the required specifications.

## Installation (Arch Linux)
These tools are available in the official Arch Linux repositories. Execute the following command in the terminal:

```sh
sudo pacman -S iverilog gtkwave
```
`Verification` to ensure the tools are correctly installed and added to your PATH, check their versions:

```sh
iverilog -v
gtkwave --version
```
## Execution Workflow
To simulate a design, you require two source files:

- The `Design File`: The actual hardware logic (e.g., counter.v).

- The `Testbench File`: A wrapper module that applies stimuli to the design (e.g., counter_tb.v).

#### Step 1: Compilation
Invoke the Icarus Verilog compiler to link the design and testbench. This process compiles the source code into a simulation executable.

```sh
iverilog <design_file>.v <testbench_file>.v
```
Note: By default, this generates a file named a.out.

#### Step 2: Simulation (Runtime)
The previous command creates an `Assembler output` file called "a.out" by executing this file we can run the simulation. Where this step performs the logic calculations and writes the signal changes to a `VCD (Value Change Dump) file`.

```sh
./a.out
```
#### Step 3: Visualization & Debugging
Launch `GTKWave` to open the generated VCD file and inspect the `waveforms`.

```sh
gtkwave <filename>.vcd
```
Note: The name of the .vcd file is determined by the `$dumpfile("filename.vcd");` system task located inside your Verilog testbench code.

# Introduction to the yosys
## Yosys (Synthesizer)

`Yosys` is the open source `synthesiszer tool` which converts the `RTL to netlist` , where we provide the `.lib` (library files) and the `design file` (i.e verilog file) to yosys to get the output as `netlist file`.

Here there are three major commands that we need to know, which are

- `read_liberty` (To read the .lib library file)  
- `read_verilog` (To read the verilog design file)  
- `write_verilog` (To write the netlist file)

The .lib is the collection of logical modules ,this includes basic logic gates like AND,OR,NOT,etc.. Different flavours of same gate like faster cell and slower cell are there and by invoking the .lib of those file we can use those cells.   
The netlist is the representation of the design in form of the cells present in the design.

#### The key Installation for the yosys 
We need `yosys` as well as the `xdot` package do that we could perform synthesis using yosys , viewing the dot file(i.e the cell mapping file) using the xdot packages 

```sh
sudo pacman -S yosys xdot
```
## Verify the Synthesis 
This is done using the `iverilog`, where we provide the `Netlist file` as well as the `Testbench file` to the `iverilog` so that we get `vcd file` and we can view using the gtkwave.

## Implementation of yosys
### Step 1
First we need to invoke the yosys , to do this just tyoe the given below in konsole(terminal)
```sh
yosys
```
After invoking you could see the changes which we will be like `yosys>`
### Step 2
Next we need to read the .lib file using the `read_liberty` and als specify the `location of the .lib file` location from the directory where you use the yosys
```sh
yosys> read_liberty -lib ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
### Step 3
We need to read the verilog file using the `read_verilog` function, which can be given as 
```sh
yosys> read_verilog good_mux.v
```
### Step 4 
We need to specify `synth -top` to specify the module which we want to synthesis 
```sh
yosys> synth -top good_mux
```
### Step 5
We need to generate the netlist we can do this by using the given below code,
Where `abc -liberty` is given to convert the rtl file to gate file where we specify the library file which we want the those rtl design to be functioned using those specified cell based library.
```sh
yosys> abc -liberty ../lib/sky130_fd_sc_hd__tt_025C_1v80.lib
```
### Step 6 
We can visualize the realized logic using the `show` command 
this gives the graphical version of that design file (where this will be in .dot file we need the xdot package to view this design in graphical window)
```sh
yosys> show
```
### Step 7
In this step we can write the netlist file using the write_verilog function followed by the netlist name which we can define 
```sh
yosys> write_verilog -noattr good_mux_netlist.v
```